# PLAN.md: Fix Resumake Help Functionality

## 1. Overview

The current `resumake --help` command correctly displays usage information generated by the standard `flag` package but then incorrectly exits with a non-zero status code and prints an error message: `Error parsing flags: flag: help requested`.

This plan outlines the steps to fix this behavior. We will modify the application to recognize when the help flag has been requested, allow the standard `flag` package to print the usage information, and then exit cleanly with a status code of 0. We will continue using the standard `flag` package for this fix, as the current CLI structure is simple and does not warrant introducing larger dependencies like Cobra or urfave/cli at this time.

## 2. Task Breakdown

| Task                                      | Description                                                                                                                               | Effort | Files/Modules Affected        |
| :---------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- | :----- | :-------------------------- |
| **1. Modify `main` Error Handling**       | Update `main.go` to specifically check if the error returned by `input.ParseFlags()` is `flag.ErrHelp`. If it is, exit cleanly (`os.Exit(0)`). | S      | `main.go`                   |
| **2. Add Integration Test for Help Flag** | Create a new test in `main_test.go` that executes the compiled binary with `-h` or `--help` and verifies a zero exit code and no error message. | M      | `main_test.go`              |
| **3. Update Unit Tests (Optional)**       | Review `input/flags_test.go` to ensure tests cover `flag.ErrHelp` being returned by `ParseFlagsWithArgs` when help is requested.            | S      | `input/flags_test.go`       |
| **4. Manual Verification**                | Manually run the application with various help flag combinations (`-h`, `--help`) and invalid flags to confirm correct behavior.            | S      | N/A (Compiled Binary)       |

## 3. Implementation Details

### Task 1: Modify `main` Error Handling

The core issue lies in how `main.go` handles the error returned from `input.ParseFlags()`. The `flag` package, when configured with `flag.ContinueOnError` (as done in `input/flags.go`), returns the special error `flag.ErrHelp` when `-h` or `--help` is encountered. The `flag` package itself handles printing the usage message in this scenario. We just need to prevent our application from treating `flag.ErrHelp` as a fatal error.

**File:** `main.go`

**Current Code:**

```go
	// Parse command-line flags
	flags, err := input.ParseFlags()
	if err != nil {
		log.Fatalf("Error parsing flags: %v", err) // <-- This catches flag.ErrHelp
	}
```

**Proposed Change:**

Insert a check for `flag.ErrHelp` *before* the general error check.

```go
import (
	"context"
	"flag" // <-- Add import for flag package
	"fmt"
	"log"
	"os" // <-- Add import for os package

	// ... other imports
)

func main() {
	fmt.Println("Resumake: A CLI tool for generating resumes")

	// Parse command-line flags
	flags, err := input.ParseFlags()
	if err != nil {
		// Check if the error is due to the user requesting help
		if err == flag.ErrHelp {
			// The flag package already printed usage information because
			// we use flag.ContinueOnError in ParseFlagsWithArgs.
			// We just need to exit cleanly.
			os.Exit(0)
		}
		// For any other parsing error, log fatally.
		log.Fatalf("Error parsing flags: %v", err)
	}

	// ... rest of the main function ...
}
```

**Explanation:**

1.  Import the `flag` and `os` packages in `main.go`.
2.  After calling `input.ParseFlags()`, check if the returned `err` is exactly `flag.ErrHelp`.
3.  If it is `flag.ErrHelp`, call `os.Exit(0)` to terminate the program successfully. The usage message will have already been printed to stderr by the `flag` package itself (because `flag.ContinueOnError` is used in `input/flags.go`).
4.  If the error is not `flag.ErrHelp`, proceed with the existing `log.Fatalf` call to report other parsing errors.

## 4. Potential Challenges & Considerations

*   **Correct Error Handling:** Ensure that only `flag.ErrHelp` results in a clean exit. All other flag parsing errors should still cause a non-zero exit code and display an error message.
*   **Standard `flag` Limitations:** While sufficient for now, if the CLI requires more complex features like subcommands or more sophisticated flag handling in the future, migrating to Cobra or urfave/cli might become necessary. This fix keeps the door open for such a migration later.
*   **Usage Message Customization:** The standard `flag` package generates a default usage message. If more customization is needed, we might need to use `fs.Usage` in `input/flags.go`, but this is outside the scope of this specific fix.

## 5. Testing Strategy

### Unit Tests

*   **`input/flags_test.go`**: Verify that `ParseFlagsWithArgs` correctly returns `flag.ErrHelp` when passed arguments like `[]string{"-h"}` or `[]string{"--help"}`. These tests likely already exist implicitly or can be slightly adjusted to explicitly check for `flag.ErrHelp`.

### Integration Tests

*   **`main_test.go`**: Add a new test function, e.g., `TestHelpFlagExitsCleanly`.
    *   Build the binary (`go build -o resumake-test-help`).
    *   Execute the binary with the help flag: `cmd := exec.Command("./resumake-test-help", "--help")`.
    *   Run the command: `output, err := cmd.CombinedOutput()`.
    *   Check the error:
        *   The `err` returned by `cmd.CombinedOutput()` should be `nil` (indicating exit code 0). If it's an `*exec.ExitError`, check `err.ExitCode()`.
    *   Check the output:
        *   `output` should contain the standard usage message (e.g., "Usage of resumake:", "-source", "-output").
        *   `output` should *not* contain the string "Error parsing flags:".
    *   Repeat for `-h`.
    *   Clean up the test binary.

### Manual Testing

1.  Run `go build`.
2.  Execute `./resumake -h`. Verify usage is printed and the command exits cleanly (check exit code with `echo $?` on Linux/macOS or `echo %errorlevel%` on Windows - should be 0). Verify no "Error parsing flags" message appears.
3.  Execute `./resumake --help`. Verify the same as above.
4.  Execute `./resumake -invalidflag`. Verify an error message *is* shown and the exit code is non-zero.
5.  Execute `./resumake` without flags (assuming it expects stdin). Verify it proceeds normally or prompts for input, without flag errors.

## 6. Open Questions

1.  Are there any specific requirements for the format or destination (stdout vs. stderr) of the help message beyond what the standard `flag` package provides? (Assumption: No, the default behavior is acceptable).
